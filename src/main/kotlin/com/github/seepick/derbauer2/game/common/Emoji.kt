package com.github.seepick.derbauer2.game.common

import java.text.BreakIterator

@JvmInline
value class Emoji(val value: String) {
    init {
        requireSingleEmoji(value)
    }

    override fun toString() = value

    companion object
}

val String.emoji get() = Emoji(this)

// generated by AI
@Suppress("MagicNumber")
fun requireSingleEmoji(value: String) {
    require(value.isNotEmpty())
    // determine grapheme clusters (may undercount some emoji sequences depending on JVM)
    val charIterator = BreakIterator.getCharacterInstance()
    charIterator.setText(value)
    var graphemeCount = 0
    while (true) {
        val end = charIterator.next()
        if (end == BreakIterator.DONE) break
        graphemeCount++
    }
    val cps = value.codePoints().toArray()
    fun Int.isEmojiBase() = when (this) {
        in 0x1F600..0x1F64F, // emoticons
        in 0x1F300..0x1F5FF, // symbols & pictographs
        in 0x1F680..0x1F6FF, // transport & map
        in 0x1F1E6..0x1F1FF, // regional indicators (flags)
        in 0x2600..0x26FF,   // misc symbols
        in 0x2700..0x27BF,   // dingbats
        in 0x1F900..0x1F9FF, // supplemental symbols & pictographs
        in 0x1FA70..0x1FAFF  // newer emoji
            -> true

        else -> false
    }

    val emojiBaseCount = cps.count { it.isEmojiBase() }
    val hasZwj = cps.any { it == 0x200D } // zero width joiner
    val regionalIndicatorCount = cps.count { it in 0x1F1E6..0x1F1FF }
    val isValidEmojiSequence = when {
        graphemeCount == 1 -> true
        hasZwj -> true
        regionalIndicatorCount == 2 -> true
        emojiBaseCount == 1 -> true
        else -> false
    }
    require(isValidEmojiSequence) {
        "Not a single emoji sequence (graphemes: $graphemeCount, emojiBases: $emojiBaseCount)"
    }
    require(emojiBaseCount >= 1) { "Not a recognized emoji sequence" }
}

// generated by AI
@Suppress("MagicNumber", "VariableMinLength")
fun String.extractGraphemes(): List<String> {
    // TODO refactor this
    val result = mutableListOf<String>()
    var start = 0
    var i = 0
    while (i < this.length) {
        // Consume base codepoint
        val codePoint = this.codePointAt(i)
        i += Character.charCount(codePoint)
        // Keep consuming modifiers, combiners, and ZWJ sequences
        while (i < this.length) {
            val nextCodePoint = this.codePointAt(i)
            when {
                // Variation selectors
                nextCodePoint in 0xFE00..0xFE0F || nextCodePoint in 0xE0100..0xE01EF -> {
                    i += Character.charCount(nextCodePoint)
                }
                // Combining diacritical marks
                nextCodePoint in 0x0300..0x036F -> {
                    i += Character.charCount(nextCodePoint)
                }
                // Emoji modifiers (skin tones)
                nextCodePoint in 0x1F3FB..0x1F3FF -> {
                    i += Character.charCount(nextCodePoint)
                }
                // Zero-width joiner
                nextCodePoint == 0x200D -> {
                    i += Character.charCount(nextCodePoint)
                    // Consume the character after ZWJ
                    if (i < this.length) {
                        val afterZWJ = this.codePointAt(i)
                        i += Character.charCount(afterZWJ)
                        // Check for variation selector after the emoji following ZWJ
                        if (i < this.length) {
                            val maybeVS = this.codePointAt(i)
                            if (maybeVS in 0xFE00..0xFE0F || maybeVS in 0xE0100..0xE01EF) {
                                i += Character.charCount(maybeVS)
                            }
                        }
                    }
                }

                else -> break // Not a combining/modifier character
            }
        }
        result.add(this.substring(start, i))
        start = i
    }
    return result
}
