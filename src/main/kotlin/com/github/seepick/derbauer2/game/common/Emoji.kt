@file:Suppress("MagicNumber")

package com.github.seepick.derbauer2.game.common

import java.text.BreakIterator

@JvmInline
value class Emoji(val value: String) {
    init {
        requireSingleEmoji(value)
    }

    override fun toString() = value

    companion object
}

val String.emoji get() = Emoji(this)

// generated by AI
fun requireSingleEmoji(value: String) {
    require(value.isNotEmpty())
    // determine grapheme clusters (may undercount some emoji sequences depending on JVM)
    val charIterator = BreakIterator.getCharacterInstance()
    charIterator.setText(value)
    var graphemeCount = 0
    while (true) {
        val end = charIterator.next()
        if (end == BreakIterator.DONE) break
        graphemeCount++
    }
    val cps = value.codePoints().toArray()
    fun Int.isEmojiBase() = when (this) {
        in 0x1F600..0x1F64F, // emoticons
        in 0x1F300..0x1F5FF, // symbols & pictographs
        in 0x1F680..0x1F6FF, // transport & map
        in 0x1F1E6..0x1F1FF, // regional indicators (flags)
        in 0x2600..0x26FF,   // misc symbols
        in 0x2700..0x27BF,   // dingbats
        in 0x1F900..0x1F9FF, // supplemental symbols & pictographs
        in 0x1FA70..0x1FAFF  // newer emoji
            -> true

        else -> false
    }

    val emojiBaseCount = cps.count { it.isEmojiBase() }
    val hasZwj = cps.any { it == 0x200D } // zero width joiner
    val regionalIndicatorCount = cps.count { it in 0x1F1E6..0x1F1FF }
    val isValidEmojiSequence = when {
        graphemeCount == 1 -> true
        hasZwj -> true
        regionalIndicatorCount == 2 -> true
        emojiBaseCount == 1 -> true
        else -> false
    }
    require(isValidEmojiSequence) {
        "Not a single emoji sequence (graphemes: $graphemeCount, emojiBases: $emojiBaseCount)"
    }
    require(emojiBaseCount >= 1) { "Not a recognized emoji sequence" }
}

// generated by AI
@Suppress("MagicNumber", "VariableMinLength")
fun String.extractGraphemes(): List<String> {
    val result = mutableListOf<String>()
    var start = 0
    var index = 0
    while (index < length) {
        index = consumeBaseCodePoint(index)
        while (index < length) {
            val next = codePointAt(index)
            val newIndex = consumeExtraCodePoint(this, index, next) ?: break
            index = newIndex
        }
        result.add(substring(start, index))
        start = index
    }
    return result
}

private fun String.consumeBaseCodePoint(index: Int): Int =
    index + Character.charCount(codePointAt(index))

private fun consumeExtraCodePoint(text: String, index: Int, codePoint: Int): Int? = when {
    codePoint.isVariationSelector() -> index + Character.charCount(codePoint)
    codePoint.isCombiningMark() -> index + Character.charCount(codePoint)
    codePoint.isSkinToneModifier() -> index + Character.charCount(codePoint)
    codePoint.isZwj() -> consumeZwjSequence(text, index)
    else -> null
}

private fun Int.isVariationSelector(): Boolean = this in 0xFE00..0xFE0F || this in 0xE0100..0xE01EF
private fun Int.isCombiningMark(): Boolean = this in 0x0300..0x036F
private fun Int.isSkinToneModifier(): Boolean = this in 0x1F3FB..0x1F3FF
private fun Int.isZwj(): Boolean = this == 0x200D

@Suppress("ReturnCount")
private fun consumeZwjSequence(text: String, index: Int): Int {
    var idx = index + Character.charCount(0x200D)
    if (idx >= text.length) {
        return idx
    }
    val afterZwj = text.codePointAt(idx)
    idx += Character.charCount(afterZwj)
    if (idx >= text.length) {
        return idx
    }
    val maybeVs = text.codePointAt(idx)
    if (maybeVs.isVariationSelector()) {
        idx += Character.charCount(maybeVs)
    }
    return idx
}
