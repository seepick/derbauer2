package com.github.seepick.derbauer2.game.core

import com.github.seepick.derbauer2.game.common.Z
import com.github.seepick.derbauer2.game.common.Zz
import com.github.seepick.derbauer2.game.common.z
import com.github.seepick.derbauer2.game.common.zz

interface HasLabels {
    val labelSingular: String
    val labelPlural: String get() = labelSingular + "s"
    fun labelFor(unsignedAmount: Z) = if (unsignedAmount == 1.z) labelSingular else labelPlural
    fun labelFor(signedAmount: Zz) = if (signedAmount == 1.zz) labelSingular else labelPlural
}

interface HasEmoji {
    val emojiOrNull: Emoji? get() = null
    val emojiSpaceOrEmpty: String get() = emojiOrNull?.let { "$it " } ?: ""
}

val String.emoji get() = Emoji(this)

@JvmInline
value class Emoji(val value: String) {
    init {
        requireSingleEmoji(value)
    }

    override fun toString() = value
}

val <T> T.emojiAndLabelSingular: String where T : HasLabels, T : HasEmoji
    get() = "$emojiSpaceOrEmpty$labelSingular"

val <T> T.emojiAndLabelPlural: String where T : HasLabels, T : HasEmoji
    get() = "$emojiSpaceOrEmpty$labelPlural"

fun <T> T.emojiAndLabelFor(unsignedAmount: Z) where T : HasLabels, T : HasEmoji =
    "$emojiSpaceOrEmpty${labelFor(unsignedAmount)}"

fun <T> T.emojiAndLabelFor(signedAmount: Zz) where T : HasLabels, T : HasEmoji =
    "$emojiSpaceOrEmpty${labelFor(signedAmount)}"

/** Generated by AI. */
@Suppress("MagicNumber")
fun requireSingleEmoji(value: String) {
    require(value.isNotEmpty())
    // determine grapheme clusters (may undercount some emoji sequences depending on JVM)
    val charIterator = java.text.BreakIterator.getCharacterInstance()
    charIterator.setText(value)
    var graphemeCount = 0
    while (true) {
        val end = charIterator.next()
        if (end == java.text.BreakIterator.DONE) break
        graphemeCount++
    }
    val cps = value.codePoints().toArray()

    fun Int.isEmojiBase() = when (this) {
        in 0x1F600..0x1F64F, // emoticons
        in 0x1F300..0x1F5FF, // symbols & pictographs
        in 0x1F680..0x1F6FF, // transport & map
        in 0x1F1E6..0x1F1FF, // regional indicators (flags)
        in 0x2600..0x26FF,   // misc symbols
        in 0x2700..0x27BF,   // dingbats
        in 0x1F900..0x1F9FF, // supplemental symbols & pictographs
        in 0x1FA70..0x1FAFF  // newer emoji
            -> true

        else -> false
    }

    val emojiBaseCount = cps.count { it.isEmojiBase() }
    val hasZwj = cps.any { it == 0x200D } // zero width joiner
    val regionalIndicatorCount = cps.count { it in 0x1F1E6..0x1F1FF }
    val isValidEmojiSequence = when {
        graphemeCount == 1 -> true
        hasZwj -> true
        regionalIndicatorCount == 2 -> true
        emojiBaseCount == 1 -> true
        else -> false
    }
    require(isValidEmojiSequence) {
        "Not a single emoji sequence (graphemes: $graphemeCount, emojiBases: $emojiBaseCount)"
    }
    require(emojiBaseCount >= 1) { "Not a recognized emoji sequence" }
}
